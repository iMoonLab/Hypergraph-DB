<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hypergraph Visualization</title>
    <!-- <script src="https://unpkg.com/@antv/g6@5/dist/g6.min.js"></script> -->
    <!-- 使用修改过的g6 -->
    <script src="http://hub.dappwind.com/static/g6.min.js"></script>
    <!-- <script src="./g6.min.js"></script> -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
    <!-- <script src="./data.js"></script> -->
    <style type="text/tailwindcss">
      @theme {
        --color-primary-50: #faf5ff;
        --color-primary-500: #8b5cf6;
        --color-primary-600: #7c3aed;
        --color-primary-700: #6d28d9;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useRef } = React;
      const { Graph } = window.G6;

      // 嵌入的数据
      const embeddedData = {{DATA_JSON}};
      // const embeddedData = datas;

      // 常量配置
      const COLORS = [
        "#F6BD16",
        "#00C9C9",
        "#F08F56",
        "#D580FF",
        "#FF3D00",
        "#16f69c",
        "#004ac9",
        "#f056d1",
        "#a680ff",
        "#c8ff00",
      ];

      // 6个预定义颜色，用于循环分配给不同的实体类型
      const ENTITY_TYPE_COLORS_PALETTE = [
        "#00C9C9",
        "#a68fff",
        "#F08F56",
        "#0d7c4f",
        "#004ac9",
        "#f056d1"
      ];

      const DEFAULT_NODE_COLOR = "#8b5cf6";

      // 动态生成实体类型颜色映射
      const generateEntityTypeColors = (vertices) => {
        const entityTypes = [...new Set(vertices.map(v => v.entity_type).filter(Boolean))];
        const colorMap = {};

        entityTypes.forEach((entityType, index) => {
          colorMap[entityType] = ENTITY_TYPE_COLORS_PALETTE[index % ENTITY_TYPE_COLORS_PALETTE.length];
        });

        return colorMap;
      };
      const LAYOUT_THRESHOLD = 100;
      const EDGE_SEPARATOR = "|#|";

      // 工具函数
      const calculateMatchScore = (vertex, searchLower) => {
        let score = 0;
        if (vertex.id.toString().toLowerCase().includes(searchLower))
          score += 3;
        if (vertex.entity_type?.toLowerCase().includes(searchLower)) score += 2;
        if (vertex.description?.toLowerCase().includes(searchLower)) score += 1;
        return score;
      };

      const createBubbleStyle = (baseColor) => ({
        fill: baseColor,
        stroke: baseColor,
        maxRoutingIterations: 100,
        maxMarchingIterations: 20,
        pixelGroup: 4,
        edgeR0: 10,
        edgeR1: 60,
        nodeR0: 15,
        nodeR1: 50,
        morphBuffer: 10,
        threshold: 4,
        memberInfluenceFactor: 1,
        edgeInfluenceFactor: 4,
        nonMemberInfluenceFactor: -0.8,
        virtualEdges: true,
      });

      const getNodeColor = (node, selectedVertex, entityTypeColors) => {
        if (node.id === selectedVertex) return "#6d28d9";
        return entityTypeColors[node.entity_type] || DEFAULT_NODE_COLOR;
      };

      const formatDescription = (description) => {
        if (!description) return "";
        return description.split("<SEP>").join(" ");
      };

      function HyperGraphViewer() {
        const containerRef = useRef(null);
        const graphRef = useRef(null);
        const [databases, setDatabases] = useState([embeddedData.database]);
        const [vertices, setVertices] = useState(embeddedData.vertices);
        const [selectedVertex, setSelectedVertex] = useState(
          embeddedData.vertices.length > 0 ? embeddedData.vertices[0].id : ""
        );
        const [graphData, setGraphData] = useState(null);
        const [loading, setLoading] = useState(false);
        const [error, setError] = useState("");
        const [searchTerm, setSearchTerm] = useState("");
        const [searchResults, setSearchResults] = useState([]);
        const [filteredVertices, setFilteredVertices] = useState(
          embeddedData.vertices
        );
        const [visualizationMode, setVisualizationMode] = useState("hyper"); // 'hyper' or 'graph'
        const [graphVersion, setGraphVersion] = useState(0);
        const [hoverHyperedge, setHoverHyperedge] = useState(null);
        const [hoverNode, setHoverNode] = useState(null);

        // 生成实体类型颜色映射
        const entityTypeColors = useMemo(() => {
          return generateEntityTypeColors(embeddedData.vertices);
        }, [embeddedData.vertices]);
        // 搜索功能
        useEffect(() => {
          if (!searchTerm.trim()) {
            setFilteredVertices(embeddedData.vertices);
            setSearchResults([]);
            return;
          }

          const searchLower = searchTerm.toLowerCase();
          const results = embeddedData.vertices
            .map((vertex) => ({
              ...vertex,
              score: calculateMatchScore(vertex, searchLower),
            }))
            .filter((item) => item.score > 0)
            .sort((a, b) => b.score - a.score)
            .map(({ score, ...vertex }) => vertex);

          setFilteredVertices(results);
          setSearchResults(results);
        }, [searchTerm]);

        // 加载图数据（从嵌入数据获取）
        useEffect(() => {
          if (selectedVertex) {
            setLoading(true);
            setError("");

            // 从嵌入数据获取图数据
            const data = embeddedData.graphs[selectedVertex];
            if (data) {
              setGraphData(data);
            } else {
              setError("Graph data not found for this vertex");
            }
            setLoading(false);
          }
        }, [selectedVertex]);

        // 转换数据为 G6 Graph 格式，根据可视化模式处理
        const graphDataFormatted = useMemo(() => {
          if (!graphData) return null;

          const hyperData = {
            nodes: Object.entries(graphData.vertices).map(([key, value]) => ({
              id: key,
              label: key,
              ...value,
            })),
            edges: [],
            hyperEdges: [],
          };
          const plugins = [];
          const edgeEntries = Object.entries(graphData.edges);

          if (visualizationMode === "graph") {
            // Graph模式：只显示维度为2的球棍图
            const edgeSet = new Set();

            edgeEntries.forEach(([key, edge]) => {
              const nodes = key.split(EDGE_SEPARATOR);
              if (nodes.length !== 2) return;

              const [a, b] = nodes;
              const edgeId = a < b ? `${a}-${b}` : `${b}-${a}`;

              if (!edgeSet.has(edgeId)) {
                edgeSet.add(edgeId);
                hyperData.edges.push({
                  id: edgeId,
                  source: a,
                  target: b,
                  ...edge,
                });
              }
            });

            // 过滤未连接的节点
            const connectedNodes = new Set();
            hyperData.edges.forEach((edge) => {
              connectedNodes.add(edge.source);
              connectedNodes.add(edge.target);
            });
            hyperData.nodes = hyperData.nodes.filter((node) =>
              connectedNodes.has(node.id)
            );
          } else {
            // Hyper模式：使用bubble-sets插件
            edgeEntries.forEach(([key, edge], i) => {
              const nodes = key.split(EDGE_SEPARATOR);

              plugins.push({
                key: `bubble-sets-${key}`,
                type: "bubble-sets",
                members: nodes,
                keywords: edge.keywords || "",
                summary: edge.summary || "",
                weight: edge.weight || nodes.length,
                ...createBubbleStyle(COLORS[i % COLORS.length]),
              });

              hyperData.hyperEdges.push({
                id: key,
                ...edge,
                members: nodes,
              });
            });
          }

          // 添加tooltip插件
          const excludedKeys = new Set([
            "id",
            "entity_name",
            "entity_type",
            "style",
            "data",
            "description",
          ]);

          plugins.push({
            type: "tooltip",
            getContent: (e, items) => {
              return items
                .map((item) => {
                  let result = `<h4>${item.id}</h4>`;
                  if (item.entity_name)
                    result += `<p><strong>Name:</strong> ${item.entity_name}</p>`;
                  if (item.entity_type)
                    result += `<p><strong>Type:</strong> ${item.entity_type}</p>`;
                  if (item.description) {
                    result += `<p><strong>Description:</strong> ${formatDescription(
                      item.description
                    )}</p>`;
                  }
                  // 展示所有剩余属性
                  Object.entries(item).forEach(([key, value]) => {
                    if (!excludedKeys.has(key)) {
                      result += `<p><strong>${key}:</strong> ${value}</p>`;
                    }
                  });
                  return result;
                })
                .join("");
            },
          });

          const isGraph = visualizationMode === "graph";

          return {
            data: hyperData,
            plugins: isGraph ? [plugins[plugins.length - 1]] : plugins,
            node: {
              palette: { field: "cluster" },
              style: {
                size: isGraph ? 20 : 25,
                labelText: (d) => d.id,
                fill: (d) => getNodeColor(d, selectedVertex, entityTypeColors),
              },
            },
            edge: {
              style: {
                size: isGraph ? 3 : 2,
                stroke: isGraph ? "#a68fff" : undefined,
                lineWidth: isGraph ? 2 : undefined,
              },
            },
            layout: {
              type:
                hyperData.nodes.length > LAYOUT_THRESHOLD
                  ? "force-atlas2"
                  : "force",
              clustering: !isGraph,
              preventOverlap: true,
              nodeClusterBy: isGraph ? undefined : "entity_type",
              gravity: 20,
              linkDistance: isGraph ? 100 : 150,
            },
            autoFit: "center",
          };
        }, [graphData, selectedVertex, visualizationMode, entityTypeColors]);

        // 初始化图形
        useEffect(() => {
          if (!graphDataFormatted || !containerRef.current) return;

          // 销毁之前的图形实例并清空画布
          if (graphRef.current && !graphRef.current.destroyed) {
            graphRef.current.clear();
            if (containerRef.current) {
              containerRef.current.innerHTML = "";
            }
          }

          const graph = new Graph({
            container: containerRef.current,
            width: containerRef.current.offsetWidth,
            height: containerRef.current.offsetHeight || 800,
            data: graphDataFormatted.data,
            behaviors: ["zoom-canvas", "drag-canvas", "drag-element"],
            autoFit: "center",
            animate: false,
            node: graphDataFormatted.node,
            edge: graphDataFormatted.edge,
            layout: graphDataFormatted.layout,
            plugins: graphDataFormatted.plugins,
          });

          graphRef.current = graph;
          graphRef.current.render();

          graph.on("pointermove", (e) => {
            if (e.targetType === "bubble-sets") {
              console.log("bubble-sets", e.target);
              const target = e.target.options;
              const newHyperedge = {
                keywords: target.keywords || "",
                summary: target.summary || "",
                members: Array.isArray(target.members) ? target.members : [],
                weight: target.weight,
              };
              // 只在数据不同时才更新
              setHoverHyperedge((prev) => {
                if (
                  !prev ||
                  prev.keywords !== newHyperedge.keywords ||
                  prev.summary !== newHyperedge.summary ||
                  prev.weight !== newHyperedge.weight ||
                  JSON.stringify(prev.members) !==
                    JSON.stringify(newHyperedge.members)
                ) {
                  return newHyperedge;
                }
                return prev;
              });
            }
            if (e.targetType === "node") {
              const target = graphDataFormatted.data.nodes.find(
                (node) => node.id === e.target.id
              );
              // 只在节点不同时才更新
              setHoverNode((prev) => {
                if (!prev || prev.id !== target?.id) {
                  return target;
                }
                return prev;
              });
            }
          });

          // 添加窗口大小变化监听
          const handleResize = () => {
            if (graphRef.current && containerRef.current) {
              graphRef.current.setSize(
                containerRef.current.offsetWidth,
                containerRef.current.offsetHeight
              );
            }
          };

          window.addEventListener("resize", handleResize);

          return () => {
            window.removeEventListener("resize", handleResize);
            if (graphRef.current && !graphRef.current.destroyed) {
              graphRef.current.clear();
            }
            if (containerRef.current) {
              containerRef.current.innerHTML = "";
            }
            // 清理右侧悬停信息
            setHoverHyperedge(null);
          };
        }, [graphDataFormatted, visualizationMode]);

        // 默认选中"最大的"节点与超边（首次或每次数据/模式变化时）
        useEffect(() => {
          if (!graphDataFormatted) return;

          const nodes = graphDataFormatted.data.nodes;
          if (!hoverNode && nodes.length > 0) {
            const nodeWithMax = nodes.reduce((best, cur) =>
              (cur.degree || 0) > (best.degree || 0) ? cur : best
            );
            setHoverNode(nodeWithMax);
          }

          if (visualizationMode === "hyper") {
            const hyperEdges = graphDataFormatted.data.hyperEdges;
            if (!hoverHyperedge && hyperEdges.length > 0) {
              const getWeight = (edge) =>
                edge.weight || edge.members?.length || 0;
              const hyperWithMax = hyperEdges.reduce((best, cur) =>
                getWeight(cur) > getWeight(best) ? cur : best
              );

              setHoverHyperedge({
                keywords: hyperWithMax.keywords || "",
                summary: hyperWithMax.summary || "",
                members: hyperWithMax.members || [],
                weight: getWeight(hyperWithMax),
              });
            }
          }
        }, [graphDataFormatted, visualizationMode, hoverNode, hoverHyperedge]);

        return (
          <div className="flex h-screen bg-gradient-to-br from-gray-50 to-gray-100">
            <div className="w-80 h-screen overflow-hidden bg-white/95 backdrop-blur-sm border-r border-gray-200/50 p-6  shadow-xl shrink-0">
              <h2 className="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                Hypergraph-DB
              </h2>

              <div className="text-lg font-bold text-gray-800 mb-3 pb-2 border-b-2 border-primary-500">
                Database Information
              </div>
              <div className="p-4 rounded-xl mb-6 text-sm border">
                <div className="flex justify-between items-center mb-2">
                  <span className="font-semibold text-gray-700">Vertices:</span>
                  <span className="font-bold text-primary-600">
                    {embeddedData.database.vertices}
                  </span>
                </div>
                <div className="flex justify-between items-center mb-2">
                  <span className="font-semibold text-gray-700">
                    Hyperedges:
                  </span>
                  <span className="font-bold text-primary-600">
                    {embeddedData.database.edges}
                  </span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="font-semibold text-gray-700">
                    Displayed Vertices:
                  </span>
                  <span className="font-bold text-primary-600">
                    {vertices.length}
                  </span>
                </div>
              </div>

              <div className="text-lg font-bold text-gray-800 mb-3 pb-2 border-b-2 border-primary-500">
                Search & Vertex List
              </div>

              {/* 搜索框 */}
              <div className="mb-4">
                <div className="relative">
                  <input
                    type="text"
                    placeholder="Search vertex ID, type or description..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter" && searchResults.length > 0) {
                        setSelectedVertex(searchResults[0].id);
                        e.target.blur();
                      }
                    }}
                    className="w-full px-4 py-2 pl-10 pr-4 text-sm border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent transition-all duration-200"
                  />
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <svg
                      className="h-4 w-4 text-gray-400"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                      />
                    </svg>
                  </div>
                  {searchTerm && (
                    <button
                      onClick={() => setSearchTerm("")}
                      className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600"
                    >
                      <svg
                        className="h-4 w-4"
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M6 18L18 6M6 6l12 12"
                        />
                      </svg>
                    </button>
                  )}
                </div>
                {searchTerm && (
                  <div className="mt-2 text-sm text-gray-600">
                    Found {searchResults.length} matching results
                    {searchResults.length > 0 && (
                      <span className="ml-2 text-xs text-gray-500">
                        (Press Enter to select first result)
                      </span>
                    )}
                  </div>
                )}
              </div>

              <div className="overflow-y-scroll hide-scrollbar h-[50vh] relative border border-gray-200 rounded-xl bg-white shadow-inner">
                {filteredVertices.length === 0 ? (
                  <div className="p-4 text-center text-gray-500">
                    {searchTerm
                      ? "No matching vertices found"
                      : "No vertex data available"}
                  </div>
                ) : (
                  filteredVertices.map((vertex) => {
                    const isSelected = selectedVertex === vertex.id;
                    const isSearchMatch = searchResults.some(
                      (r) => r.id === vertex.id
                    );
                    const highlightClass = isSelected
                      ? "bg-primary-50 border-l-4 border-l-primary-500 shadow-md"
                      : isSearchMatch
                      ? "bg-yellow-50 border-l-4 border-l-yellow-400 shadow-sm"
                      : "";

                    return (
                      <div
                        key={vertex.id}
                        className={`p-2 border-b border-gray-100 cursor-pointer transition-all duration-200 hover:bg-gray-50 hover:shadow-sm ${highlightClass}`}
                        onClick={() => setSelectedVertex(vertex.id)}
                      >
                        <div className="font-bold text-gray-800 mb-2 flex items-center">
                          {vertex.id}
                          {isSearchMatch && (
                            <span className="ml-2 px-2 py-1 bg-yellow-200 text-yellow-800 rounded text-xs font-semibold">
                              Match
                            </span>
                          )}
                        </div>
                        <div className="text-sm text-gray-600 flex gap-2 items-center">
                          <div className="flex items-center">
                            <span className="font-medium">
                              {vertex.entity_type ? "Type" : "ID"}:
                            </span>
                            <span className="ml-2 px-2 py-1 bg-gray-100 rounded text-xs">
                              {vertex.entity_type || vertex.id}
                            </span>
                          </div>
                          <div className="flex items-center">
                            <span className="font-medium">Degree:</span>
                            <span className="ml-2 px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs font-semibold">
                              {vertex.degree}
                            </span>
                          </div>
                        </div>
                        {vertex.description && (
                          <div className="mt-2 text-xs text-gray-500 bg-gray-50 p-2 rounded">
                            {formatDescription(vertex.description)}
                          </div>
                        )}
                      </div>
                    );
                  })
                )}
              </div>
            </div>

            <div className="flex-1 flex flex-col bg-white/10 backdrop-blur-sm">
              <div className="bg-white/95 p-4 border-b border-gray-200/50 flex justify-between items-center shadow-sm">
                <div className="flex items-center gap-4">
                  <h3 className="text-xl font-semibold text-gray-800 m-0">
                    {visualizationMode === "hyper" ? "Hypergraph" : "Graph"}{" "}
                    Visualization {selectedVertex && `- ${selectedVertex}`}
                  </h3>

                  {/* 可视化模式选择器 */}
                  <div className="flex items-center gap-2">
                    <span className="text-sm text-gray-600">Mode:</span>
                    <div className="flex space-x-1">
                      {["hyper", "graph"].map((mode) => (
                        <button
                          key={mode}
                          onClick={() => setVisualizationMode(mode)}
                          className={`px-3 py-1 text-xs rounded-full transition-all duration-200 ${
                            visualizationMode === mode
                              ? "bg-primary-500 text-white shadow-md"
                              : "bg-gray-100 text-gray-600 hover:bg-gray-200"
                          }`}
                        >
                          {mode === "hyper" ? "HyperGraph" : "Graph"}
                        </button>
                      ))}
                    </div>
                  </div>
                </div>

                {graphData && (
                  <div className="bg-white px-4 py-2 text-sm text-gray-600 rounded-lg shadow-sm border border-gray-200">
                    <span className="font-semibold">Vertices:</span>{" "}
                    {Object.keys(graphData.vertices).length} |
                    <span className="font-semibold ml-1">
                      {visualizationMode === "hyper" ? "Hyperedges:" : "Edges:"}
                    </span>{" "}
                    {visualizationMode === "hyper"
                      ? Object.keys(graphData.edges).length
                      : graphDataFormatted?.data?.edges?.length || 0}
                  </div>
                )}
              </div>

              <div className="flex-1 relative bg-white">
                {error && (
                  <div className="bg-red-50 text-red-700 p-4 m-4 rounded-lg border-l-4 border-red-500 shadow-sm">
                    <div className="flex items-center">
                      <span className="text-xl mr-2">⚠️</span>
                      <span className="font-medium">{error}</span>
                    </div>
                  </div>
                )}

                {loading && (
                  <div className="flex justify-center items-center h-full text-lg text-gray-600">
                    <div className="text-center">
                      <div className="text-2xl mb-4">🔄</div>
                      <div className="font-semibold">
                        Loading hypergraph data...
                      </div>
                      <div className="text-sm mt-2 text-gray-500">
                        This may take a few seconds
                      </div>
                    </div>
                  </div>
                )}

                {!loading && (
                  <div className="flex h-[calc(100vh-71px)]">
                    <div
                      ref={containerRef}
                      className="w-full rounded-xl h-full"
                    />
                    {visualizationMode === "hyper" && (
                      <div className="shrink-0 w-72 h-full overflow-y-auto bg-white/95 backdrop-blur-sm border-l border-gray-200/50 p-3 shadow-xl overflow-y-auto">
                        <div className="text-lg font-bold text-gray-800 mb-3 pb-2 border-b-2 border-primary-500">
                          HyperGraph Detail
                        </div>
                        {hoverHyperedge && (
                          <div className="text-sm text-gray-700 space-y-3 border-b-2 border-primary-500 pb-6">
                            <div className="text-base font-semibold text-gray-900">
                              HyperEdge
                            </div>
                            {hoverHyperedge.keywords && (
                              <div>
                                <span className="font-medium">Keywords:</span>
                                <div className="flex flex-wrap gap-2 mt-2">
                                  {hoverHyperedge.keywords
                                    .split(/,|，|、|。|<SEP>/)
                                    .map((keyword, i) => (
                                      <span
                                        key={i}
                                        className="inline-block p-1 bg-primary-50 rounded"
                                      >
                                        {keyword}
                                      </span>
                                    ))}
                                </div>
                              </div>
                            )}
                            {hoverHyperedge.summary && (
                              <div>
                                <div className="font-medium">Summary:</div>
                                <div className="mt-1 text-gray-600 bg-gray-50 p-2 rounded">
                                  {hoverHyperedge.summary}
                                </div>
                              </div>
                            )}
                            {hoverHyperedge.members?.length > 0 && (
                              <div>
                                <div className="font-medium">
                                  Nodes ({hoverHyperedge.members.length}):
                                </div>
                                <div className="flex flex-wrap gap-2 mt-2">
                                  {hoverHyperedge.members.map((member, i) => (
                                    <span
                                      key={i}
                                      className="p-1 bg-primary-50 rounded"
                                    >
                                      {member}
                                    </span>
                                  ))}
                                </div>
                              </div>
                            )}
                          </div>
                        )}
                        {hoverNode && (
                          <div className="text-sm text-gray-700 space-y-3 mt-4">
                            <div className="text-base font-semibold text-gray-900">
                              Node
                            </div>
                            {hoverNode.entity_name && (
                              <div>
                                <span className="font-medium">Name:</span>
                                <span className="ml-2">
                                  {hoverNode.entity_name}
                                </span>
                              </div>
                            )}
                            {hoverNode.entity_type && (
                              <div>
                                <span className="font-medium">Type:</span>
                                <span className="ml-2 inline-block px-2 py-0.5 bg-gray-100 rounded">
                                  {hoverNode.entity_type}
                                </span>
                              </div>
                            )}
                            {hoverNode.description && (
                              <div>
                                <span className="font-medium">
                                  Description:
                                </span>
                                <span className="ml-2">
                                  {formatDescription(hoverNode.description)}
                                </span>
                              </div>
                            )}
                            {hoverNode.additional_properties && (
                              <div>
                                <span className="font-medium">
                                  Additional Properties:
                                </span>
                                <span className="ml-2">
                                  {formatDescription(
                                    hoverNode.additional_properties
                                  )}
                                </span>
                              </div>
                            )}
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                )}
              </div>
            </div>
          </div>
        );
      }

      ReactDOM.render(<HyperGraphViewer />, document.getElementById("root"));
    </script>
  </body>
</html>
